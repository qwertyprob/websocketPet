#!/usr/bin/env node
var j1=Object.defineProperty;var pe=Object.getOwnPropertyDescriptor;var ge=Object.getOwnPropertyNames;var he=Object.prototype.hasOwnProperty;var P1=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(e,o)=>(typeof require<"u"?require:e)[o]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),H1=t=>e=>{var o=t[e];if(o)return o();throw new Error("Module not found in bundle: "+e)};var L=(t,e)=>()=>(t&&(e=t(t=0)),e);var n1=(t,e)=>{for(var o in e)j1(t,o,{get:e[o],enumerable:!0})},ue=(t,e,o,i)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of ge(e))!he.call(t,n)&&n!==o&&j1(t,n,{get:()=>e[n],enumerable:!(i=pe(e,n))||i.enumerable});return t};var s1=t=>ue(j1({},"__esModule",{value:!0}),t);import{access as h2,mkdir as u2,readFile as Et,writeFile as w2}from"fs/promises";import{dirname as x2}from"path";import{parse as v2}from"jsonc-parser";var l,j,b,y2,k2,u,z,b2,z2,C2,l1,m=L(()=>{"use strict";l=async t=>{try{return await h2(t),!0}catch{return!1}},j=async()=>{if(await l("pnpm-workspace.yaml"))return!0;try{let t=v2(await Et("package.json","utf-8"));return t?!!t.workspaces||!!t.workspace:!1}catch{return!1}},b=async({dependencies:t,devDependencies:e,scripts:o})=>{let i=await Et("package.json","utf8"),n=JSON.parse(i),s={...n};(n.devDependencies||e)&&(s.devDependencies={...n.devDependencies,...e}),(n.dependencies||t)&&(s.dependencies={...n.dependencies,...t}),(n.scripts||o)&&(s.scripts={...n.scripts,...o}),await w2("package.json",JSON.stringify(s,null,2))},y2=/[ $(){}[\]&|;<>!"'`*?#~]/,k2=/'/g,u=t=>t.map(e=>y2.test(e)?`'${e.replace(k2,"'\\''")}' `:e),z=async t=>{let e=x2(t);if(e!=="."){let o=e.startsWith("./")?e.slice(2):e;await u2(o,{recursive:!0})}},b2=["./biome.json","./biome.jsonc"],z2=["./eslint.config.mjs","./eslint.config.js","./eslint.config.cjs","./eslint.config.ts","./eslint.config.mts","./eslint.config.cts"],C2="./.oxlintrc.json",l1=async()=>{for(let t of b2)if(await l(t))return"biome";for(let t of z2)if(await l(t))return"eslint";return await l(C2)?"oxlint":null}});var Rt={};n1(Rt,{husky:()=>F});import{execSync as r3}from"child_process";import{mkdir as a3,readFile as c3,writeFile as Ut}from"fs/promises";import{addDevDependency as l3,dlxCommand as F1}from"nypm";var Dt,g1,F,$1=L(()=>{"use strict";m();Dt=t=>`#!/bin/sh
# Exit on any error
set -e

# Check if there are any staged files
if [ -z "$(git diff --cached --name-only)" ]; then
  echo "No staged files to format"
  exit 0
fi

# Store the hash of staged changes to detect modifications
STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)

# Save list of staged files (handling all file states)
STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMR)
PARTIALLY_STAGED=$(git diff --name-only)

# Stash unstaged changes to preserve working directory
# --keep-index keeps staged changes in working tree
git stash push --quiet --keep-index --message "pre-commit-stash" || true
STASHED=$?

# Run formatter on the staged files
${t}
FORMAT_EXIT_CODE=$?

# Restore working directory state
if [ $STASHED -eq 0 ]; then
  # Re-stage the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
  
  # Restore unstaged changes
  git stash pop --quiet || true
  
  # Restore partial staging if files were partially staged
  if [ -n "$PARTIALLY_STAGED" ]; then
    for file in $PARTIALLY_STAGED; do
      if [ -f "$file" ] && echo "$STAGED_FILES" | grep -q "^$file$"; then
        # File was partially staged - need to unstage the unstaged parts
        git restore --staged "$file" 2>/dev/null || true
        git add -p "$file" < /dev/null 2>/dev/null || git add "$file"
      fi
    done
  fi
else
  # No stash was created, just re-add the formatted files
  if [ -n "$STAGED_FILES" ]; then
    echo "$STAGED_FILES" | while IFS= read -r file; do
      if [ -f "$file" ]; then
        git add "$file"
      fi
    done
  fi
fi

# Check if staged files actually changed
NEW_STAGED_HASH=$(git diff --cached | sha256sum | cut -d' ' -f1)
if [ "$STAGED_HASH" != "$NEW_STAGED_HASH" ]; then
  echo "\u2728 Files formatted by Ultracite"
fi

exit $FORMAT_EXIT_CODE
`,g1="./.husky/pre-commit",F={exists:()=>l(g1),install:async t=>{await l3("husky",{packageManager:t,workspace:await j(),silent:!0}),await b({scripts:{prepare:"husky"}})},init:t=>{let e=F1(t,"husky",{args:["init"]});try{r3(e,{stdio:"pipe"})}catch{}},create:async t=>{await a3(".husky",{recursive:!0});let e=F1(t,"ultracite",{args:["fix"],short:t==="npm"}),o=Dt(e);await Ut(g1,o)},update:async t=>{let e=await c3(g1,"utf-8"),o=F1(t,"ultracite",{args:["fix"],short:t==="npm"}),i=Dt(o);await Ut(g1,`${e}
${i}`)}}});var Mt={};n1(Mt,{lefthook:()=>V});import{execSync as f3}from"child_process";import{readFile as d3,writeFile as Z}from"fs/promises";import{addDevDependency as m3,dlxCommand as Tt}from"nypm";var p3,g3,Gt,$,Nt,V,_1=L(()=>{"use strict";m();p3=/(pre-commit:\s*\n\s*jobs:\s*\n)/,g3=/(pre-commit:\s*\n)/,Gt=t=>Tt(t,"ultracite",{args:["fix"],short:t==="npm"}),$="./lefthook.yml",Nt=t=>`pre-commit:
  jobs:
    - run: ${Gt(t)}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true
`,V={exists:()=>l($),install:async t=>{await m3("lefthook",{packageManager:t,workspace:await j(),silent:!0}),await b({scripts:{prepare:"lefthook install"}});let e=Tt(t,"lefthook",{args:["install"],short:t==="npm"});f3(e,{stdio:"pipe"})},create:async t=>{let e=Nt(t);await Z($,e)},update:async t=>{let e=await d3($,"utf-8"),o=Gt(t),i=Nt(t);if(e.includes(o))return;if(e.startsWith("# EXAMPLE USAGE:")){await Z($,i);return}if(e.includes("pre-commit:"))if(e.includes("jobs:")){let s=`    - run: ${o}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true`,r=e.replace(p3,`$1${s}
`);await Z($,r)}else{let s=`  jobs:
    - run: ${o}
      glob: 
        - "*.js"
        - "*.jsx"
        - "*.ts"
        - "*.tsx"
        - "*.json"
        - "*.jsonc"
        - "*.css"
      stage_fixed: true`,r=e.replace(g3,`$1${s}
`);await Z($,r)}else await Z($,`${e}
${i}`)}}});var Ht={};n1(Ht,{preCommit:()=>t1});import{readFile as h3,writeFile as L1}from"fs/promises";import{dlxCommand as u3}from"nypm";var q,w3,Jt,x3,t1,U1=L(()=>{"use strict";m();q="./.pre-commit-config.yaml",w3=/^repos:\s*\n/m,Jt=t=>u3(t,"ultracite",{args:["fix"],short:t==="npm"}),x3=t=>`repos:
  - repo: local
    hooks:
      - id: ultracite
        name: ultracite
        entry: ${Jt(t)}
        language: system
        types_or: [javascript, jsx, ts, tsx, json, css]
        pass_filenames: false
`,t1={exists:()=>l(q),create:async t=>{let e=x3(t);await L1(q,e)},update:async t=>{let e=await h3(q,"utf-8"),o=Jt(t);if(e.includes("id: ultracite"))return;let i=`  - repo: local
    hooks:
      - id: ultracite
        name: ultracite
        entry: ${o}
        language: system
        types_or: [javascript, jsx, ts, tsx, json, css]
        pass_filenames: false
`;if(e.includes("repos:")){let n=e.replace(w3,`repos:
${i}`);await L1(q,n)}else await L1(q,`${e}
repos:
${i}`)}}});var v3,D1=L(()=>{v3=H1({"./husky.ts":()=>($1(),s1(Rt)),"./lefthook.ts":()=>(_1(),s1(Mt)),"./lint-staged.ts":()=>(R1(),s1(Wt)),"./pre-commit.ts":()=>(U1(),s1(Ht))})});var Wt={};n1(Wt,{lintStaged:()=>X});import{readFile as h1,writeFile as _}from"fs/promises";import{pathToFileURL as y3}from"url";import e1 from"deepmerge";import{parse as T1}from"jsonc-parser";import{addDevDependency as k3,dlxCommand as b3}from"nypm";var E,Vt,z3,C3,S3,j3,P3,E3,A3,I3,O3,N1,B3,X,R1=L(()=>{"use strict";m();D1();E=t=>({"*.{js,jsx,ts,tsx,json,jsonc,css,scss,md,mdx}":[b3(t,"ultracite",{args:["fix"],short:t==="npm"})]}),Vt=["./package.json","./.lintstagedrc.json","./.lintstagedrc.js","./.lintstagedrc.cjs","./.lintstagedrc.mjs","./lint-staged.config.js","./lint-staged.config.cjs","./lint-staged.config.mjs","./.lintstagedrc.yaml","./.lintstagedrc.yml","./.lintstagedrc"],z3=(t,e,o,i)=>{let n=t.trim();if(n.includes(":")&&!n.startsWith("-")){o&&i.length>0&&(e[o]=i);let[s,...r]=n.split(":"),a=r.join(":").trim(),f=s.trim().replace(/['"]/g,"");return a&&a!==""?(a.startsWith("[")&&a.endsWith("]")?e[f]=a.slice(1,-1).split(",").map(p=>p.trim().replace(/['"]/g,"")):e[f]=a.replace(/['"]/g,""),{newCurrentKey:null,newCurrentArray:[]}):{newCurrentKey:f,newCurrentArray:[]}}if(n.startsWith("-")&&o){let s=[...i,n.slice(1).trim().replace(/['"]/g,"")];return{newCurrentKey:o,newCurrentArray:s}}return{newCurrentKey:o,newCurrentArray:i}},C3=t=>{let e=t.split(`
`).filter(s=>s.trim()&&!s.trim().startsWith("#")),o={},i=null,n=[];for(let s of e){let r=z3(s,o,i,n);i=r.newCurrentKey,n=r.newCurrentArray}return i&&n.length>0&&(o[i]=n),o},S3=t=>{let e="";for(let[o,i]of Object.entries(t))if(Array.isArray(i)){e+=`${o}:
`;for(let n of i)e+=`  - '${n}'
`}else e+=`${o}: '${i}'
`;return e},j3=async()=>{try{let t=T1(await h1("./package.json","utf-8"));return t?t.type==="module":!1}catch{return!1}},P3=async t=>{let e=T1(await h1("./package.json","utf-8"));e&&(e["lint-staged"]?e["lint-staged"]=e1(e["lint-staged"],E(t)):e["lint-staged"]=E(t),await _("./package.json",JSON.stringify(e,null,2)))},E3=async(t,e)=>{let o=await h1(t,"utf-8"),i=T1(o);if(!i)return;let n=e1(i,E(e));await _(t,JSON.stringify(n,null,2))},A3=async(t,e)=>{let o=await h1(t,"utf-8"),i=C3(o);if(!i)return;let n=e1(i,E(e));await _(t,S3(n))},I3=async(t,e)=>{let n=(await import(y3(t).href)).default||{},s=e1(n,E(e)),r=`export default ${JSON.stringify(s,null,2)};
`;await _(t,r)},O3=async(t,e)=>{delete P1.cache[P1.resolve(`./${t}`)];let o=v3(`./${t}`),i=e1(o,E(e)),n=`module.exports = ${JSON.stringify(i,null,2)};
`;await _(t,n)},N1=async t=>{await _(".lintstagedrc.json",JSON.stringify(E(t),null,2))},B3=async(t,e)=>{if(t==="./package.json"){await P3(e);return}if(t.endsWith(".json")||t==="./.lintstagedrc"){await E3(t,e);return}if(t.endsWith(".yaml")||t.endsWith(".yml")){await A3(t,e);return}let o=await j3();if(t.endsWith(".mjs")||t.endsWith(".js")&&o){try{await I3(t,e)}catch{await N1(e)}return}if(t.endsWith(".cjs")||t.endsWith(".js")&&!o)try{await O3(t,e)}catch{await N1(e)}},X={exists:async()=>{for(let t of Vt)if(await l(t))return!0;return!1},install:async t=>{await k3("lint-staged",{packageManager:t,workspace:await j(),silent:!0})},create:async t=>{await _(".lintstagedrc.json",JSON.stringify(E(t),null,2))},update:async t=>{let e=null;for(let o of Vt)if(await l(o)){e=o;break}if(!e){await N1(t);return}await B3(e,t)}}});var W1="./aider-K7JLZT2D.svg";var V1="./amazon-q-TSOJNPXB.svg";var X1="./amp-EV4LVL5I.svg";var Q1="./augmentcode-Q62PVXKO.svg";var K1="./claude-6DLEHRDQ.svg";var Y1="./cline-6HWKIYN7.svg";var Z1="./codex-NQZ5TJCL.svg";var q1="./copilot-L2IY45R2.svg";var tt="./crush-LYLRDQGZ.svg";var r1="./cursor-GQNH5LCA.svg";var et="./droid-266OHJBT.svg";var ot="./firebase-studio-ILLWWYU7.svg";var it="./firebender-UNO6LSZG.svg";var nt="./gemini-OYS6V4BH.svg";var st="./goose-XBIEVD4H.svg";var rt="./jules-HJPVWU73.svg";var at="./junie-RUWBUV6N.svg";var ct="./kilo-code-4QYUYY2E.svg";var lt="./mistral-HQ63EC2B.svg";var ft="./open-hands-K5EYKO6T.svg";var dt="./opencode-K3274JKQ.svg";var mt="./qwen-N3D5CQYL.svg";var pt="./roo-code-CVLBTS7D.svg";var gt="./vercel-27VSITAQ.svg";var ht="./warp-OZKAAQRT.svg";var C=[{id:"claude",name:"Claude Code",subtitle:"Anthropic's agentic CLI",description:"Anthropic's official CLI for Claude, an agentic coding tool that lives in your terminal.",config:{path:".claude/CLAUDE.md",appendMode:!0},logo:K1,hooks:{path:".claude/settings.json",getContent:t=>({hooks:{PostToolUse:[{matcher:"Write|Edit",hooks:[{type:"command",command:t}]}]}})}},{id:"codex",name:"Codex",subtitle:"OpenAI's coding agent",description:"OpenAI's cloud-based coding agent for autonomous software development tasks.",config:{path:"AGENTS.md",appendMode:!0},logo:Z1},{id:"jules",name:"Jules",subtitle:"Google's async agent",description:"Google's asynchronous AI coding agent that works in the background to complete development tasks.",config:{path:"AGENTS.md",appendMode:!0},logo:rt},{id:"copilot",name:"GitHub Copilot",subtitle:"GitHub's AI pair programmer",description:"GitHub's AI pair programmer that suggests code completions and helps write code faster.",config:{path:".github/copilot-instructions.md",appendMode:!0,header:`---
applyTo: "**/*.{ts,tsx,js,jsx}"
---`},logo:q1},{id:"cline",name:"Cline",subtitle:"Autonomous VS Code agent",description:"An autonomous coding agent for VS Code that can create and edit files, run commands, and more.",config:{path:".clinerules",appendMode:!0},logo:Y1},{id:"amp",name:"AMP",subtitle:"Sourcegraph's coding agent",description:"Sourcegraph's AI coding agent that understands your entire codebase for intelligent assistance.",config:{path:"AGENT.md",appendMode:!0},logo:X1},{id:"aider",name:"Aider",subtitle:"Terminal pair programming",description:"AI pair programming in your terminal with support for multiple LLM providers.",config:{path:"ultracite.md"},logo:W1},{id:"firebase-studio",name:"Firebase Studio",subtitle:"Google's cloud IDE",description:"Google's AI-powered development environment integrated with Firebase services.",config:{path:".idx/airules.md",appendMode:!0},logo:ot},{id:"open-hands",name:"OpenHands",subtitle:"Open-source AI agents",description:"An open-source platform for AI software development agents with autonomous capabilities.",config:{path:".openhands/microagents/repo.md",appendMode:!0},logo:ft},{id:"gemini",name:"Gemini",subtitle:"Google's terminal AI",description:"Google's command-line interface for Gemini, bringing AI assistance to your terminal.",config:{path:"GEMINI.md",appendMode:!0},logo:nt},{id:"junie",name:"Junie",subtitle:"JetBrains' AI agent",description:"JetBrains' AI coding agent integrated into their IDE ecosystem.",config:{path:".junie/guidelines.md",appendMode:!0},logo:at},{id:"augmentcode",name:"Augment Code",subtitle:"Enterprise AI assistant",description:"An AI coding assistant focused on enterprise development workflows and team collaboration.",config:{path:".augment/rules/ultracite.md"},logo:Q1},{id:"kilo-code",name:"Kilo Code",subtitle:"Customizable VS Code AI",description:"A VS Code extension providing AI-powered coding assistance with customizable rules.",config:{path:".kilocode/rules/ultracite.md"},logo:ct},{id:"goose",name:"Goose",subtitle:"Block's open-source agent",description:"Block's open-source AI developer agent for autonomous software development.",config:{path:".goosehints",appendMode:!0},logo:st},{id:"roo-code",name:"Roo Code",subtitle:"Codebase navigation AI",description:"An AI coding assistant focused on understanding and navigating complex codebases.",config:{path:".roo/rules/ultracite.md",appendMode:!0},logo:pt},{id:"warp",name:"Warp",subtitle:"Modern AI terminal",description:"A modern terminal with AI-powered command suggestions and workflow automation.",config:{path:"WARP.md",appendMode:!0},logo:ht},{id:"droid",name:"Droid",subtitle:"Automated code generation",description:"An AI development agent focused on automated code generation and task completion.",config:{path:"AGENTS.md",appendMode:!0},logo:et},{id:"opencode",name:"OpenCode",subtitle:"Open-source coding agent",description:"An open-source AI coding agent that runs in your terminal, desktop, or IDE with support for 75+ LLM providers.",config:{path:"AGENTS.md",appendMode:!0},logo:dt},{id:"crush",name:"Crush",subtitle:"Glamorous terminal agent",description:"Charmbracelet's glamorous AI coding agent for your terminal with multi-model support.",config:{path:"CRUSH.md",appendMode:!0},logo:tt},{id:"qwen",name:"Qwen Code",subtitle:"Alibaba's coding CLI",description:"Alibaba's command-line interface for Qwen3-Coder, enabling agentic coding with natural language.",config:{path:"AGENTS.md",appendMode:!0},logo:mt},{id:"amazon-q-cli",name:"Amazon Q CLI",subtitle:"AWS's terminal AI",description:"Amazon's AI-powered CLI with command autocompletion, natural language chat, and AWS integration.",config:{path:".amazonq/rules/ultracite.md",appendMode:!0},logo:V1},{id:"firebender",name:"Firebender",subtitle:"Android Studio AI",description:"The most powerful AI coding assistant for Android Studio with codebase context and up-to-date Android knowledge.",config:{path:"firebender.json"},logo:it},{id:"cursor-cli",name:"Cursor CLI",subtitle:"Cursor's terminal agent",description:"Cursor's CLI, built to help you ship right from your terminal.",config:{path:".cursor/rules/ultracite.mdc",appendMode:!0},logo:r1},{id:"mistral-vibe",name:"Mistral Vibe",subtitle:"Minimal CLI coding agent",description:"Mistral's minimal CLI coding agent for streamlined development tasks.",config:{path:"VIBE.md"},logo:lt},{id:"vercel",name:"Vercel Agent",subtitle:"Vercel's AI Cloud agent",description:"Vercel's agent, powered by their AI Cloud.",config:{path:"AGENTS.md",appendMode:!0},logo:gt}];import U from"deepmerge";var ut="./antigravity-JVONECNW.svg";var wt="./kiro-N2M256R6.svg";var xt="./trae-RXVCFBOF.svg";var vt="./void-NYH3U3BB.svg";var yt="./vscode-DEOUEB65.svg";var kt="./windsurf-5T7JOTST.svg";var bt="./zed-SIARPESF.svg";var a1={"editor.defaultFormatter":"esbenp.prettier-vscode","typescript.tsdk":"node_modules/typescript/lib","editor.formatOnSave":!0,"editor.formatOnPaste":!0,"emmet.showExpandedAbbreviation":"never"},Qe={"[javascript]":{"editor.defaultFormatter":"biomejs.biome"},"[typescript]":{"editor.defaultFormatter":"biomejs.biome"},"[javascriptreact]":{"editor.defaultFormatter":"biomejs.biome"},"[typescriptreact]":{"editor.defaultFormatter":"biomejs.biome"},"[json]":{"editor.defaultFormatter":"biomejs.biome"},"[jsonc]":{"editor.defaultFormatter":"biomejs.biome"},"[html]":{"editor.defaultFormatter":"biomejs.biome"},"[vue]":{"editor.defaultFormatter":"biomejs.biome"},"[svelte]":{"editor.defaultFormatter":"biomejs.biome"},"[css]":{"editor.defaultFormatter":"biomejs.biome"},"[yaml]":{"editor.defaultFormatter":"biomejs.biome"},"[graphql]":{"editor.defaultFormatter":"biomejs.biome"},"[markdown]":{"editor.defaultFormatter":"biomejs.biome"},"[mdx]":{"editor.defaultFormatter":"biomejs.biome"},"editor.codeActionsOnSave":{"source.fixAll.biome":"explicit","source.organizeImports.biome":"explicit"}},Ke={"[javascript]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[javascriptreact]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[typescript]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[typescriptreact]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[json]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[jsonc]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[yaml]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[html]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[vue]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[vue-html]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[handlebars]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[css]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[scss]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[less]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[graphql]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"[markdown]":{"editor.defaultFormatter":"oxc.oxc-vscode"},"editor.codeActionsOnSave":{"source.fixAll.oxc":"explicit"}},Ye={"editor.codeActionsOnSave":{"source.fixAll.eslint":"explicit","source.organizeImports":"explicit"}},A=(t="biome")=>{switch(t){case"biome":return U(a1,Qe);case"eslint":return U(a1,Ye);case"oxlint":return U(a1,Ke);default:return a1}},c1={formatter:"language_server",format_on_save:"on",lsp:{"typescript-language-server":{settings:{typescript:{preferences:{includePackageJsonAutoImports:"on"}}}}}},Ze={languages:{JavaScript:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},TypeScript:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}},TSX:{formatter:{language_server:{name:"biome"}},code_actions_on_format:{"source.fixAll.biome":!0,"source.organizeImports.biome":!0}}}},qe={languages:{JavaScript:{formatter:{language_server:{name:"eslint"}},code_actions_on_format:{"source.fixAll.eslint":!0,"source.organizeImports.eslint":!0}},TypeScript:{formatter:{language_server:{name:"eslint"}},code_actions_on_format:{"source.fixAll.eslint":!0,"source.organizeImports.eslint":!0}},TSX:{formatter:{language_server:{name:"eslint"}},code_actions_on_format:{"source.fixAll.eslint":!0,"source.organizeImports.eslint":!0}}}},t2={languages:{JavaScript:{formatter:{language_server:{name:"oxfmt"}},code_actions_on_format:{"source.fixAll.oxc":!0,"source.organizeImports.oxc":!0}},TypeScript:{formatter:{language_server:{name:"oxfmt"}},code_actions_on_format:{"source.fixAll.oxc":!0,"source.organizeImports.oxc":!0}},TSX:{formatter:{language_server:{name:"oxfmt"}},code_actions_on_format:{"source.fixAll.oxc":!0,"source.organizeImports.oxc":!0}}},lsp:{oxlint:{initialization_options:{settings:{disableNestedConfig:!1,fixKind:"safe_fix",run:"onType",typeAware:!0,unusedDisableDirectives:"deny"}}},oxfmt:{initialization_options:{settings:{configPath:null,flags:{},"fmt.configPath":null,"fmt.experimental":!0,run:"onSave",typeAware:!1,unusedDisableDirectives:!1}}}}},e2=(t="biome")=>{switch(t){case"biome":return U(c1,Ze);case"eslint":return U(c1,qe);case"oxlint":return U(c1,t2);default:return c1}},S=[{id:"vscode",name:"Visual Studio Code",subtitle:"The most popular code editor",description:"Microsoft's popular code editor with extensive extension support and built-in Git integration.",logo:yt,config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"cursor",name:"Cursor",subtitle:"The AI-first code editor",description:"The AI-first code editor built on VS Code with deep AI integration for coding assistance.",logo:r1,rules:{path:".cursor/rules/ultracite.mdc",header:`---
description: Ultracite Rules - AI-Ready Formatter and Linter
globs: "**/*.{ts,tsx,js,jsx,json,jsonc,html,vue,svelte,astro,css,yaml,yml,graphql,gql,md,mdx,grit}"
alwaysApply: false
---`},hooks:{path:".cursor/hooks.json",getContent:t=>({version:1,hooks:{afterFileEdit:[{command:t}]}})},config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"windsurf",name:"Windsurf",subtitle:"The agentic IDE by Codeium",description:"Codeium's agentic IDE that combines AI assistance with a powerful VS Code-based development environment.",logo:kt,rules:{path:".windsurf/rules/ultracite.md"},hooks:{path:".windsurf/hooks.json",getContent:t=>({hooks:{post_write_code:[{command:t,show_output:!0}]}})},config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"antigravity",name:"Antigravity",subtitle:"Google's next-generation IDE",description:"An AI-powered development platform built on VS Code for building and deploying applications faster.",logo:ut,config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"kiro",name:"Kiro",subtitle:"AWS's spec-driven IDE",description:"AWS's spec-driven AI development environment for building production-ready applications.",logo:wt,rules:{path:".kiro/steering/ultracite.md"},config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"trae",name:"Trae AI",subtitle:"ByteDance's AI IDE",description:"ByteDance's AI-powered IDE built on VS Code - the real AI engineer.",logo:xt,rules:{path:".trae/rules/project_rules.md"},config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"void",name:"Void",subtitle:"Open-source AI editor",description:"An open-source AI code editor built on VS Code with a focus on privacy and extensibility.",logo:vt,config:{path:".vscode/settings.json",getContent:A,extensionCommand:"code --install-extension"}},{id:"zed",name:"Zed",subtitle:"The high-performance editor",description:"A high-performance, multiplayer code editor built in Rust with built-in AI assistance.",logo:bt,rules:{path:".rules",appendMode:!0},config:{path:".zed/settings.json",getContent:e2}}];var o2=t=>!!t.hooks,i2=t=>!!t.hooks,n2=()=>S.filter(o2).map(t=>({id:t.id,name:t.name,hooks:t.hooks})),s2=()=>C.filter(i2).map(t=>({id:t.id,name:t.name,hooks:t.hooks})),I=[...n2(),...s2()];var zt="./biome-TVLEY2T4.svg";var Ct="./eslint-7IULJKW7.svg";var St="./oxlint-5IE3ABOZ.svg";var jt="./prettier-O4V2FSEA.svg";var Pt="./stylelint-DEBSWZVS.svg";var D=[{id:"biome",name:"Biome",subtitle:"The modern all-in-one toolchain",description:"The modern, all-in-one toolchain. Biome is a fast formatter and linter written in Rust that handles JavaScript, TypeScript, JSON, CSS, and more with a single tool.",benefits:[{title:"Lightning fast",description:"Written in Rust, Biome can format a large codebase in milliseconds.",icon:"Zap"},{title:"All-in-one toolchain",description:"No more juggling ESLint, Prettier, and other tools. Biome handles formatting and linting in a single pass.",icon:"Layers"},{title:"287 preconfigured rules",description:"Covers accessibility, complexity, correctness, performance, security, style, and suspicious patterns.",icon:"ShieldCheck"},{title:"Multi-language support",description:"Natively supports JavaScript, TypeScript, JSX, TSX, JSON, JSONC, CSS, GraphQL, and HTML.",icon:"Code"},{title:"Smart sorting",description:"Automatically organizes imports and JSX attributes, plus sorts Tailwind CSS classes.",icon:"ArrowUpDown"},{title:"Zero dependencies",description:"Biome has no JavaScript dependencies. One binary does everything with consistent behavior.",icon:"Package"}],logo:zt,videos:["https://www.youtube.com/watch?v=lEkXbneUnWg","https://www.youtube.com/watch?v=b_F4LaycQcE"],configFiles:[{name:"biome.jsonc",lang:"json",code:t=>`{
  "$schema": "./node_modules/@biomejs/biome/configuration_schema.json",
  "extends": [
    ${t.map(e=>`"ultracite/biome/${e}"`).join(`,
    `)}
  ]
}`}],vscodeExtensionId:"biomejs.biome"},{id:"eslint",name:"ESLint + Prettier + Stylelint",subtitle:"The most mature linting ecosystem",description:"The most mature and comprehensive linting solution. Combines ESLint for JavaScript/TypeScript, Prettier for formatting, and Stylelint for CSS with 20+ plugins and hundreds of preconfigured rules.",benefits:[{title:"Battle-tested",description:"Used by millions of developers worldwide. The largest ecosystem of plugins and configurations available.",icon:"ShieldCheck"},{title:"20+ plugins included",description:"React, TypeScript, JSX A11y, Import, Promise, Node, Next.js, Unicorn, SonarJS, and more preconfigured.",icon:"Puzzle"},{title:"Three tools in one",description:"ESLint handles code quality, Prettier ensures consistent formatting, and Stylelint keeps your CSS clean.",icon:"Layers"},{title:"Framework-aware",description:"First-class support for React, Next.js, Vue, Svelte, and more with framework-specific rules.",icon:"Box"},{title:"Type-aware linting",description:"Deep TypeScript integration with type-aware rules that catch bugs static analysis alone can't find.",icon:"FileCode"},{title:"Maximum coverage",description:"Hundreds of rules covering accessibility, security, performance, and best practices out of the box.",icon:"Target"}],includes:["ESLint","Prettier","Stylelint"],logo:Ct,additionalLogos:[jt,Pt],configFiles:[{name:"eslint.config.mjs",lang:"javascript",code:t=>`import { defineConfig } from "eslint/config";
${t.map(e=>`import ${e} from "ultracite/eslint/${e}";`).join(`
`)}

export default defineConfig([
  {
    extends: [
      ${t.join(`,
      `)}
    ],
  },
]);`},{name:"prettier.config.mjs",lang:"javascript",code:()=>'export { default } from "ultracite/prettier";'},{name:"stylelint.config.mjs",lang:"javascript",code:()=>'export { default } from "ultracite/stylelint";'}],vscodeExtensionId:"dbaeumer.vscode-eslint"},{id:"oxlint",name:"Oxlint + Oxfmt",subtitle:"The fastest linter available",description:"The fastest linter available. Oxlint is part of the Oxc project, running 50-100x faster than ESLint with a focus on catching bugs and reducing false positives.",benefits:[{title:"50-100x faster",description:"Lint your entire codebase in milliseconds. No more waiting for slow linting processes.",icon:"Zap"},{title:"15 plugin equivalents",description:"Built-in support for React, TypeScript, Next.js, Vue, Jest, Vitest, JSDoc, and more without extra deps.",icon:"Puzzle"},{title:"Bug-focused rules",description:"Prioritizes catching real bugs over stylistic issues. High signal-to-noise ratio.",icon:"Bug"},{title:"Oxc ecosystem",description:"Part of the larger Oxc project with parser, resolver, transformer, and minifier built for speed.",icon:"Boxes"},{title:"Category-based config",description:"Rules organized into correctness, suspicious, pedantic, performance, restriction, and style categories.",icon:"FolderTree"},{title:"Drop-in ready",description:"Works alongside your existing ESLint setup or as a complete replacement with Oxfmt for formatting.",icon:"RefreshCw"}],includes:["Oxlint","Oxfmt"],logo:St,configFiles:[{name:".oxlintrc.json",lang:"json",code:t=>`{
  "$schema": "./node_modules/oxlint/configuration_schema.json",
  "extends": [
    ${t.map(e=>`"./node_modules/ultracite/config/oxlint/${e}/.oxlintrc.json"`).join(`,
    `)}
  ]
}`},{name:".oxfmtrc.jsonc",lang:"json",code:()=>`{
  "$schema": "./node_modules/oxfmt/configuration_schema.json",
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "arrowParens": "always",
  "proseWrap": "never",
  "printWidth": 80,
}`}],vscodeExtensionId:"oxc.oxc-vscode"}];var d2=["react","next","solid","vue","svelte","qwik","remix","angular","astro"],m2=["husky","lefthook","lint-staged","pre-commit"],p2=["eslint","prettier"],v={linters:D.map(t=>t.id),editorConfigs:S.map(t=>t.id),agents:C.map(t=>t.id),integrations:m2,hooks:I.map(t=>t.id),frameworks:d2,migrations:p2};import{initTRPC as jo}from"@trpc/server";import{packageManagers as Po}from"nypm";import{createCli as Eo}from"trpc-cli";import c from"zod";var k={name:"ultracite",description:"The AI-ready formatter that helps you write and generate code faster.",version:"7.0.11",type:"module",bin:{ultracite:"dist/index.js"},files:["config","dist/index.js","dist/index.d.ts","README.md"],scripts:{build:"tsup",test:"bun test","test:coverage":"bun test --coverage"},exports:{"./biome/*":"./config/biome/*/biome.jsonc","./eslint/*":"./config/eslint/*/eslint.config.mjs","./oxlint/*":"./config/oxlint/*/.oxlintrc.json","./prettier":"./config/prettier/prettier.config.mjs","./stylelint":"./config/stylelint/stylelint.config.mjs","./*":"./config/biome/*/biome.jsonc"},author:"Hayden Bleasel <hello@haydenbleasel.com>",bugs:{url:"https://github.com/haydenbleasel/ultracite/issues"},homepage:"https://www.ultracite.ai/",keywords:["ultracite","biome","linter","formatter","fixer"],license:"MIT",publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},repository:{type:"git",url:"git+https://github.com/haydenbleasel/ultracite.git"},devDependencies:{"@biomejs/biome":"2.3.11","@eslint/js":"^9.39.2","@next/eslint-plugin-next":"^16.1.1","@repo/data":"workspace:*","@tanstack/eslint-plugin-query":"^5.91.2","@types/node":"^25.0.3","@typescript-eslint/eslint-plugin":"^8.52.0","@typescript-eslint/parser":"^8.52.0","eslint-config-prettier":"^10.1.8","eslint-import-resolver-typescript":"^4.4.4","eslint-plugin-angular":"^5.0.0","eslint-plugin-astro":"^1.5.0","eslint-plugin-compat":"^6.0.2","eslint-plugin-cypress":"^5.2.1","eslint-plugin-github":"6.0.0","eslint-plugin-html":"^8.1.3","eslint-plugin-import":"^2.32.0","eslint-plugin-jest":"^29.12.1","eslint-plugin-jsx-a11y":"^6.10.2","eslint-plugin-n":"^17.23.1","eslint-plugin-prettier":"^5.5.4","eslint-plugin-promise":"^7.2.1","eslint-plugin-qwik":"^1.18.0","eslint-plugin-react":"^7.37.5","eslint-plugin-react-hooks":"^7.0.1","eslint-plugin-remix":"^1.1.1","eslint-plugin-solid":"^0.14.5","eslint-plugin-sonarjs":"^3.0.5","eslint-plugin-storybook":"^10.1.11","eslint-plugin-svelte":"^3.14.0","eslint-plugin-tailwindcss":"^3.18.2","eslint-plugin-unicorn":"^62.0.0","eslint-plugin-unused-imports":"^4.3.0","eslint-plugin-vue":"^10.6.2",globals:"^17.0.0","prettier-plugin-tailwindcss":"^0.7.2","stylelint-config-idiomatic-order":"^10.0.0","stylelint-config-standard":"^39.0.1","stylelint-prettier":"^5.0.3",tsup:"^8.5.1",oxlint:"^1.38.0"},dependencies:{"@clack/prompts":"^0.11.0","@trpc/server":"^11.8.1",deepmerge:"^4.3.1",glob:"^13.0.0","jsonc-parser":"^3.3.1",nypm:"^0.6.2","trpc-cli":"^0.12.2",zod:"^4.3.5"},peerDependencies:{oxlint:"^1.0.0"},peerDependenciesMeta:{oxlint:{optional:!0}},packageManager:"bun@1.3.5"};m();import{spawnSync as R}from"child_process";import N from"process";import{detectPackageManager as T,dlxCommand as G}from"nypm";var S2=async(t,e,o)=>{let i=["check","--no-errors-on-unmatched"];e&&i.push(`--diagnostic-level=${e}`),o&&i.push("--error-on-warnings"),t.length>0?i.push(...u(t)):i.push("./");let s=(await T(N.cwd()))?.name||"npm",r=G(s,"@biomejs/biome",{args:i,short:s==="npm"}),a=R(r,{stdio:"inherit",shell:!0});if(a.error)throw new Error(`Failed to run Biome: ${a.error.message}`);return{hasErrors:a.status!==0}},j2=async t=>{let e=t.length>0?u(t):["."],i=(await T(N.cwd()))?.name||"npm",n=G(i,"eslint",{args:e,short:i==="npm"}),s=R(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run ESLint: ${s.error.message}`);return{hasErrors:s.status!==0}},P2=async t=>{let e=["--check",...t.length>0?u(t):["."]],i=(await T(N.cwd()))?.name||"npm",n=G(i,"prettier",{args:e,short:i==="npm"}),s=R(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run Prettier: ${s.error.message}`);return{hasErrors:s.status!==0}},E2=async t=>{let e=t.length>0?u(t):["."],i=(await T(N.cwd()))?.name||"npm",n=G(i,"stylelint",{args:e,short:i==="npm"}),s=R(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run Stylelint: ${s.error.message}`);return{hasErrors:s.status!==0}},A2=async(t,e,o)=>{let i=[];e&&i.push("--type-aware"),o&&i.push("--type-check"),i.push(...t.length>0?u(t):["."]);let s=(await T(N.cwd()))?.name||"npm",r=G(s,"oxlint",{args:i,short:s==="npm"}),a=R(r,{stdio:"inherit",shell:!0});if(a.error)throw new Error(`Failed to run Oxlint: ${a.error.message}`);return{hasErrors:a.status!==0}},I2=async(t,e)=>{let o=["--check"];e&&o.push("--no-error-on-unmatched-pattern"),o.push(...t.length>0?u(t):["."]);let n=(await T(N.cwd()))?.name||"npm",s=G(n,"oxfmt",{args:o,short:n==="npm"}),r=R(s,{stdio:"inherit",shell:!0});if(r.error)throw new Error(`Failed to run oxfmt: ${r.error.message}`);return{hasErrors:r.status!==0}},At=async t=>{let e=t?.[0]||[],o=t?.[1]["diagnostic-level"],n=t?.[1].linter||await l1();if(!n)throw new Error("No linter configuration found. Run `ultracite init` to set up a linter.");switch(n){case"eslint":{let s=await P2(e),r=await j2(e),a=await E2(e);return{hasErrors:s.hasErrors||r.hasErrors||a.hasErrors}}case"oxlint":{let s=await I2(e,t?.[1]["no-error-on-unmatched-pattern"]),r=await A2(e,t?.[1]["type-aware"],t?.[1]["type-check"]);return{hasErrors:s.hasErrors||r.hasErrors}}default:return S2(e,o,t?.[1]["error-on-warnings"])}};import{spawnSync as A1}from"child_process";import{existsSync as O}from"fs";import{readFile as d1}from"fs/promises";import{join as B}from"path";import w from"process";import{intro as O2,log as f1,outro as E1,spinner as B2}from"@clack/prompts";import{parse as It}from"jsonc-parser";import{detectPackageManager as m1,dlxCommand as p1}from"nypm";var F2=[".prettierrc",".prettierrc.js",".prettierrc.cjs",".prettierrc.mjs",".prettierrc.json",".prettierrc.yaml",".prettierrc.yml","prettier.config.js","prettier.config.mjs","prettier.config.cjs"],$2=[".eslintrc",".eslintrc.js",".eslintrc.cjs",".eslintrc.mjs",".eslintrc.json",".eslintrc.yaml",".eslintrc.yml","eslint.config.js","eslint.config.mjs","eslint.config.cjs","eslint.config.ts","eslint.config.mts","eslint.config.cts"],_2=async()=>{let e=(await m1(w.cwd()))?.name||"npm",o=p1(e,"@biomejs/biome",{args:["--version"],short:e==="npm"}),i=A1(o,{shell:!0,encoding:"utf-8"});return i.status===0&&i.stdout?{name:"Biome installation",status:"pass",message:`Biome is installed (${i.stdout.trim()})`}:{name:"Biome installation",status:"fail",message:"Biome is not installed or not accessible"}},L2=async()=>{let e=(await m1(w.cwd()))?.name||"npm",o=p1(e,"eslint",{args:["--version"],short:e==="npm"}),i=A1(o,{shell:!0,encoding:"utf-8"});return i.status===0&&i.stdout?{name:"ESLint installation",status:"pass",message:`ESLint is installed (${i.stdout.trim()})`}:{name:"ESLint installation",status:"warn",message:"ESLint is not installed (optional)"}},U2=async()=>{let e=(await m1(w.cwd()))?.name||"npm",o=p1(e,"oxlint",{args:["--version"],short:e==="npm"}),i=A1(o,{shell:!0,encoding:"utf-8"});return i.status===0&&i.stdout?{name:"Oxlint installation",status:"pass",message:`Oxlint is installed (${i.stdout.trim()})`}:{name:"Oxlint installation",status:"warn",message:"Oxlint is not installed (optional)"}},D2=async()=>{let t=B(w.cwd(),"biome.json"),e=B(w.cwd(),"biome.jsonc"),o=null;if(O(t)?o=t:O(e)&&(o=e),!o)return{name:"Biome configuration",status:"warn",message:"No biome.json or biome.jsonc file found"};try{let i=await d1(o,"utf-8"),n=It(i);return Array.isArray(n?.extends)&&n.extends.includes("ultracite/biome/core")?{name:"Biome configuration",status:"pass",message:"biome.json(c) extends ultracite/biome/core"}:{name:"Biome configuration",status:"warn",message:"biome.json(c) exists but doesn't extend ultracite/biome/core"}}catch{return{name:"Biome configuration",status:"fail",message:"Could not parse biome.json(c) file"}}},R2=async()=>{let t=["eslint.config.mjs","eslint.config.js","eslint.config.cjs","eslint.config.ts","eslint.config.mts","eslint.config.cts"],e=null;for(let o of t){let i=B(w.cwd(),o);if(O(i)){e=i;break}}if(!e)return{name:"ESLint configuration",status:"warn",message:"No eslint.config.* file found (optional)"};try{return(await d1(e,"utf-8")).includes("ultracite/eslint")?{name:"ESLint configuration",status:"pass",message:"eslint.config.* imports ultracite/eslint"}:{name:"ESLint configuration",status:"warn",message:"eslint.config.* exists but doesn't import ultracite/eslint"}}catch{return{name:"ESLint configuration",status:"fail",message:"Could not read eslint.config.* file"}}},N2=t=>`./node_modules/ultracite/config/oxlint/${t}/.oxlintrc.json`,T2=async()=>{let t=B(w.cwd(),".oxlintrc.json");if(!O(t))return{name:"Oxlint configuration",status:"warn",message:"No .oxlintrc.json file found (optional)"};try{let e=await d1(t,"utf-8"),o=It(e);return Array.isArray(o?.extends)&&o.extends.includes(N2("core"))?{name:"Oxlint configuration",status:"pass",message:".oxlintrc.json extends ultracite oxlint config"}:{name:"Oxlint configuration",status:"warn",message:".oxlintrc.json exists but doesn't extend ultracite config"}}catch{return{name:"Oxlint configuration",status:"fail",message:"Could not parse .oxlintrc.json file"}}},G2=async()=>{let t=B(w.cwd(),"package.json");if(!O(t))return{name:"Ultracite dependency",status:"warn",message:"No package.json found"};try{let e=JSON.parse(await d1(t,"utf-8")),o=e.dependencies?.ultracite||e.devDependencies?.ultracite||e.peerDependencies?.ultracite;return o?{name:"Ultracite dependency",status:"pass",message:`Ultracite is in package.json (${o})`}:{name:"Ultracite dependency",status:"warn",message:"Ultracite not found in package.json dependencies"}}catch{return{name:"Ultracite dependency",status:"warn",message:"Could not parse package.json"}}},M2=()=>{let t=F2.some(i=>O(B(w.cwd(),i))),o=$2.filter(i=>!i.startsWith("eslint.config")).some(i=>O(B(w.cwd(),i)));if(t||o){let i=[];return t&&i.push("Prettier"),o&&i.push("ESLint (legacy config)"),{name:"Conflicting tools",status:"warn",message:`Found potentially conflicting tools: ${i.join(", ")}`}}return{name:"Conflicting tools",status:"pass",message:"No conflicting formatting/linting tools found"}},P=async(t,e)=>{let o=B2();o.start(`Checking ${e}...`);let i=await t();return i.status==="pass"||i.status,o.stop(i.message),i},Ot=async()=>{O2(`Ultracite v${k.version} Doctor`);let e=(await m1(w.cwd()))?.name||"npm",o=p1(e,"ultracite",{args:["init"],short:e==="npm"}),i=[];i.push(await P(_2,"Biome installation")),i.push(await P(L2,"ESLint installation")),i.push(await P(U2,"Oxlint installation")),i.push(await P(D2,"Biome configuration")),i.push(await P(R2,"ESLint configuration")),i.push(await P(T2,"Oxlint configuration")),i.push(await P(G2,"Ultracite dependency")),i.push(await P(M2,"conflicting tools"));let n=i.filter(a=>a.status==="pass").length,s=i.filter(a=>a.status==="fail").length,r=i.filter(a=>a.status==="warn").length;if(f1.info(`Summary: ${n} passed, ${r} warnings, ${s} failed`),s>0)throw f1.error(`Some checks failed. Run '${o}' to fix issues.`),E1("Doctor complete"),new Error("Doctor checks failed");if(r>0){f1.warn(`Some optional improvements available. Run '${o}' to configure.`),E1("Doctor complete");return}f1.success("Everything looks good!"),E1("Doctor complete")};m();import{spawnSync as M}from"child_process";import J from"process";import{detectPackageManager as H,dlxCommand as W}from"nypm";var J2=async(t,e,o)=>{let i=["check","--write","--no-errors-on-unmatched"];e&&i.push("--unsafe"),o&&i.push("--error-on-warnings"),t.length>0?i.push(...u(t)):i.push("./");let s=(await H(J.cwd()))?.name||"npm",r=W(s,"@biomejs/biome",{args:i,short:s==="npm"}),a=M(r,{stdio:"inherit",shell:!0});if(a.error)throw new Error(`Failed to run Biome: ${a.error.message}`);return{hasErrors:a.status!==0}},H2=async t=>{let e=["--fix",...t.length>0?u(t):["."]],i=(await H(J.cwd()))?.name||"npm",n=W(i,"eslint",{args:e,short:i==="npm"}),s=M(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run ESLint: ${s.error.message}`);return{hasErrors:s.status!==0}},W2=async t=>{let e=["--write",...t.length>0?u(t):["."]],i=(await H(J.cwd()))?.name||"npm",n=W(i,"prettier",{args:e,short:i==="npm"}),s=M(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run Prettier: ${s.error.message}`);return{hasErrors:s.status!==0}},V2=async t=>{let e=["--fix",...t.length>0?u(t):["."]],i=(await H(J.cwd()))?.name||"npm",n=W(i,"stylelint",{args:e,short:i==="npm"}),s=M(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run Stylelint: ${s.error.message}`);return{hasErrors:s.status!==0}},X2=async(t,e,o,i)=>{let n=[i?"--fix-dangerously":"--fix"];e&&n.push("--type-aware"),o&&n.push("--type-check"),n.push(...t.length>0?u(t):["."]);let r=(await H(J.cwd()))?.name||"npm",a=W(r,"oxlint",{args:n,short:r==="npm"}),f=M(a,{stdio:"inherit",shell:!0});if(f.error)throw new Error(`Failed to run Oxlint: ${f.error.message}`);return{hasErrors:f.status!==0}},Q2=async t=>{let e=["--write",...t.length>0?u(t):["."]],i=(await H(J.cwd()))?.name||"npm",n=W(i,"oxfmt",{args:e,short:i==="npm"}),s=M(n,{stdio:"inherit",shell:!0});if(s.error)throw new Error(`Failed to run oxfmt: ${s.error.message}`);return{hasErrors:s.status!==0}},Bt=async(t,e={})=>{let o=e.linter||await l1();if(!o)throw new Error("No linter configuration found. Run `ultracite init` to set up a linter.");switch(o){case"eslint":{let i=await W2(t),n=await H2(t),s=await V2(t);return{hasErrors:i.hasErrors||n.hasErrors||s.hasErrors}}case"oxlint":{let i=await Q2(t),n=await X2(t,e["type-aware"],e["type-check"],e.unsafe);return{hasErrors:i.hasErrors||n.hasErrors}}default:return J2(t,e.unsafe,e["error-on-warnings"])}};import so from"process";import{cancel as K,intro as ro,isCancel as Y,log as C1,multiselect as o1,select as ao,spinner as g}from"@clack/prompts";import{addDevDependency as co,detectPackageManager as lo}from"nypm";import{readFile as K2,writeFile as I1}from"fs/promises";var Ft=(t,e)=>`# Ultracite Code Standards

This project uses **Ultracite**, a zero-config preset that enforces strict code quality standards through automated formatting and linting.

## Quick Reference

- **Format code**: \`${t} ultracite fix\`
- **Check for issues**: \`${t} ultracite check\`
- **Diagnose setup**: \`${t} ultracite doctor\`

${e} (the underlying engine) provides robust linting and formatting. Most issues are automatically fixable.

---

## Core Principles

Write code that is **accessible, performant, type-safe, and maintainable**. Focus on clarity and explicit intent over brevity.

### Type Safety & Explicitness

- Use explicit types for function parameters and return values when they enhance clarity
- Prefer \`unknown\` over \`any\` when the type is genuinely unknown
- Use const assertions (\`as const\`) for immutable values and literal types
- Leverage TypeScript's type narrowing instead of type assertions
- Use meaningful variable names instead of magic numbers - extract constants with descriptive names

### Modern JavaScript/TypeScript

- Use arrow functions for callbacks and short functions
- Prefer \`for...of\` loops over \`.forEach()\` and indexed \`for\` loops
- Use optional chaining (\`?.\`) and nullish coalescing (\`??\`) for safer property access
- Prefer template literals over string concatenation
- Use destructuring for object and array assignments
- Use \`const\` by default, \`let\` only when reassignment is needed, never \`var\`

### Async & Promises

- Always \`await\` promises in async functions - don't forget to use the return value
- Use \`async/await\` syntax instead of promise chains for better readability
- Handle errors appropriately in async code with try-catch blocks
- Don't use async functions as Promise executors

### React & JSX

- Use function components over class components
- Call hooks at the top level only, never conditionally
- Specify all dependencies in hook dependency arrays correctly
- Use the \`key\` prop for elements in iterables (prefer unique IDs over array indices)
- Nest children between opening and closing tags instead of passing as props
- Don't define components inside other components
- Use semantic HTML and ARIA attributes for accessibility:
  - Provide meaningful alt text for images
  - Use proper heading hierarchy
  - Add labels for form inputs
  - Include keyboard event handlers alongside mouse events
  - Use semantic elements (\`<button>\`, \`<nav>\`, etc.) instead of divs with roles

### Error Handling & Debugging

- Remove \`console.log\`, \`debugger\`, and \`alert\` statements from production code
- Throw \`Error\` objects with descriptive messages, not strings or other values
- Use \`try-catch\` blocks meaningfully - don't catch errors just to rethrow them
- Prefer early returns over nested conditionals for error cases

### Code Organization

- Keep functions focused and under reasonable cognitive complexity limits
- Extract complex conditions into well-named boolean variables
- Use early returns to reduce nesting
- Prefer simple conditionals over nested ternary operators
- Group related code together and separate concerns

### Security

- Add \`rel="noopener"\` when using \`target="_blank"\` on links
- Avoid \`dangerouslySetInnerHTML\` unless absolutely necessary
- Don't use \`eval()\` or assign directly to \`document.cookie\`
- Validate and sanitize user input

### Performance

- Avoid spread syntax in accumulators within loops
- Use top-level regex literals instead of creating them in loops
- Prefer specific imports over namespace imports
- Avoid barrel files (index files that re-export everything)
- Use proper image components (e.g., Next.js \`<Image>\`) over \`<img>\` tags

### Framework-Specific Guidance

**Next.js:**
- Use Next.js \`<Image>\` component for images
- Use \`next/head\` or App Router metadata API for head elements
- Use Server Components for async data fetching instead of async Client Components

**React 19+:**
- Use ref as a prop instead of \`React.forwardRef\`

**Solid/Svelte/Vue/Qwik:**
- Use \`class\` and \`for\` attributes (not \`className\` or \`htmlFor\`)

---

## Testing

- Write assertions inside \`it()\` or \`test()\` blocks
- Avoid done callbacks in async tests - use async/await instead
- Don't use \`.only\` or \`.skip\` in committed code
- Keep test suites reasonably flat - avoid excessive \`describe\` nesting

## When ${e} Can't Help

${e}'s linter will catch most issues automatically. Focus your attention on:

1. **Business logic correctness** - ${e} can't validate your algorithms
2. **Meaningful naming** - Use descriptive names for functions, variables, and types
3. **Architecture decisions** - Component structure, data flow, and API design
4. **Edge cases** - Handle boundary conditions and error states
5. **User experience** - Accessibility, performance, and usability considerations
6. **Documentation** - Add comments for complex logic, but prefer self-documenting code

---

Most formatting and common issues are automatically fixed by ${e}. Run \`${t} ultracite fix\` before committing to ensure compliance.
`;m();import{dlxCommand as Y2}from"nypm";var $t=(t,e,o)=>{let i=C.find(f=>f.id===t);if(!i)throw new Error(`Agent "${t}" not found`);let n=D.find(f=>f.id===o);if(!n)throw new Error(`Provider "${o}" not found`);let s=Y2(e,""),r=Ft(s,n.name),a=i.config.header?`${i.config.header}

${r}`:r;return{exists:()=>l(i.config.path),create:async()=>{await z(i.config.path),await I1(i.config.path,a)},update:async()=>{await z(i.config.path);let f=await l(i.config.path);if(!(i.config.appendMode&&f)){await I1(i.config.path,a);return}let p=await K2(i.config.path,"utf-8");p.includes(r.trim())||await I1(i.config.path,`${p}

${r}`)}}};import{spawnSync as Z2}from"child_process";import{readFile as q2,writeFile as O1}from"fs/promises";m();import t3 from"deepmerge";import{parse as e3}from"jsonc-parser";var _t=(t,e="biome")=>{let o=S.find(n=>n.id===t);if(!o)throw new Error(`Editor "${t}" not found`);let i=o.config.getContent(e);return{exists:()=>l(o.config.path),create:async()=>{await z(o.config.path),await O1(o.config.path,JSON.stringify(i,null,2))},update:async()=>{if(await z(o.config.path),!await l(o.config.path)){await O1(o.config.path,JSON.stringify(i,null,2));return}let s=await q2(o.config.path,"utf-8"),a=e3(s)||{},f=t3(a,i);await O1(o.config.path,JSON.stringify(f,null,2))},extension:o.config.extensionCommand?n=>Z2(`${o.config.extensionCommand} ${n}`,{stdio:"pipe",shell:!0}):void 0}};import{readFile as o3,writeFile as B1}from"fs/promises";m();import i3 from"deepmerge";import{parse as n3}from"jsonc-parser";import{dlxCommand as s3}from"nypm";var Lt=(t,e)=>{let o=I.find(f=>f.id===t);if(!o)throw new Error(`Hook integration "${t}" not found`);let i=s3(e,"ultracite",{args:["fix"],short:e==="npm"}),n=o.hooks.getContent(i),s=f=>typeof f=="object"&&f!==null&&!Array.isArray(f),r=f=>JSON.stringify(f).includes("ultracite"),a=async()=>{if(!await l(o.hooks.path)){await B1(o.hooks.path,JSON.stringify(n,null,2));return}let p=await o3(o.hooks.path,"utf-8"),y=n3(p),x=s(y)?y:{};if(!r(x)){let d=i3(x,n);await B1(o.hooks.path,JSON.stringify(d,null,2))}};return{exists:()=>l(o.hooks.path),create:async()=>{await z(o.hooks.path),await B1(o.hooks.path,JSON.stringify(n,null,2))},update:async()=>{await z(o.hooks.path),await a()}}};$1();_1();R1();U1();m();import{readFile as F3,writeFile as Xt}from"fs/promises";import $3 from"deepmerge";import{parse as _3}from"jsonc-parser";var Qt={$schema:"./node_modules/@biomejs/biome/configuration_schema.json",extends:["ultracite/biome/core"]},G1=async()=>await l("./biome.json")?"./biome.json":"./biome.jsonc",u1={exists:async()=>{let t=await G1();return l(t)},create:async t=>{let e=await G1(),o=["ultracite/biome/core"];if(t?.frameworks&&t.frameworks.length>0)for(let n of t.frameworks)o.push(`ultracite/biome/${n}`);let i={...Qt,extends:o};return Xt(e,JSON.stringify(i,null,2))},update:async t=>{let e=await G1(),o=await F3(e,"utf-8"),n=_3(o)||{},r=[...n.extends&&Array.isArray(n.extends)?n.extends:[]];if(r.includes("ultracite/biome/core")||r.push("ultracite/biome/core"),t?.frameworks&&t.frameworks.length>0)for(let p of t.frameworks){let y=`ultracite/biome/${p}`;r.includes(y)||r.push(y)}n.extends=r;let a={$schema:Qt.$schema},f=$3(n,a);await Xt(e,JSON.stringify(f,null,2))}};m();import{writeFile as Kt}from"fs/promises";var L3=["./eslint.config.mjs","./eslint.config.js","./eslint.config.cjs","./eslint.config.ts","./eslint.config.mts","./eslint.config.cts"],Yt="./eslint.config.mjs",U3=async()=>{for(let t of L3)if(await l(t))return t;return null},Zt=t=>{let e=['import core from "ultracite/eslint/core";'],o=["...core"];if(t?.frameworks&&t.frameworks.length>0)for(let i of t.frameworks)e.push(`import ${i} from "ultracite/eslint/${i}";`),o.push(`...${i}`);return`${e.join(`
`)}

export default [
  ${o.join(`,
  `)},
];
`},w1={exists:async()=>await U3()!==null,create:async t=>{let e=Zt(t);await Kt(Yt,e)},update:async t=>{let e=Zt(t);await Kt(Yt,e)}};m();import{readFile as D3,writeFile as qt}from"fs/promises";import R3 from"deepmerge";import{parse as N3}from"jsonc-parser";var x1="./.oxfmtrc.jsonc",te={$schema:"./node_modules/oxfmt/configuration_schema.json",printWidth:80,tabWidth:2,useTabs:!1,semi:!0,singleQuote:!1,quoteProps:"as-needed",jsxSingleQuote:!1,trailingComma:"es5",bracketSpacing:!0,bracketSameLine:!1,arrowParens:"always",endOfLine:"lf",experimentalSortPackageJson:!0,experimentalSortImports:{ignoreCase:!0,newlinesBetween:!0,order:"asc"}},v1={exists:async()=>await l(x1),create:async()=>{let t=`// Ultracite oxfmt Configuration
// https://oxc.rs/docs/guide/usage/formatter/config-file-reference.html
${JSON.stringify(te,null,2)}
`;return await qt(x1,t)},update:async()=>{let t=await D3(x1,"utf-8"),o=N3(t)||{},i=R3(o,te),n=`// Ultracite oxfmt Configuration
// https://oxc.rs/docs/guide/usage/formatter/config-file-reference.html
${JSON.stringify(i,null,2)}
`;await qt(x1,n)}};m();import{readFile as T3,writeFile as ee}from"fs/promises";import G3 from"deepmerge";import{parse as M3}from"jsonc-parser";var y1="./.oxlintrc.json",Q=t=>`./node_modules/ultracite/config/oxlint/${t}/.oxlintrc.json`,oe={$schema:"./node_modules/oxlint/configuration_schema.json",extends:[Q("core")]},k1={exists:async()=>await l(y1),create:async t=>{let e=[Q("core")];if(t?.frameworks&&t.frameworks.length>0)for(let i of t.frameworks)e.push(Q(i));let o={...oe,extends:e};return await ee(y1,JSON.stringify(o,null,2))},update:async t=>{let e=await T3(y1,"utf-8"),i=M3(e)||{},n=i.extends&&Array.isArray(i.extends)?i.extends:[],s=p=>n.some(y=>y===Q(p)),r=[...n];if(s("core")||r.push(Q("core")),t?.frameworks&&t.frameworks.length>0)for(let p of t.frameworks)s(p)||r.push(Q(p));i.extends=r;let a={$schema:oe.$schema},f=G3(i,a);await ee(y1,JSON.stringify(f,null,2))}};m();import{readFile as J3,writeFile as ie}from"fs/promises";var H3=["./.prettierrc.mjs","./prettier.config.mjs","./.prettierrc.mts","./prettier.config.mts","./.prettierrc.cjs","./prettier.config.cjs","./.prettierrc.cts","./prettier.config.cts","./.prettierrc.js","./prettier.config.js","./.prettierrc.ts","./prettier.config.ts","./.prettierrc","./.prettierrc.json","./.prettierrc.json5","./.prettierrc.yml","./.prettierrc.yaml","./.prettierrc.toml"],ne="./prettier.config.mjs",W3=async()=>{try{return"prettier"in JSON.parse(await J3("./package.json","utf-8"))}catch{return!1}},V3=async()=>{if(await W3())return"./package.json";for(let t of H3)if(await l(t))return t;return null},se=()=>`export { default } from "ultracite/prettier";
`,b1={exists:async()=>await V3()!==null,create:async()=>{let t=se();await ie(ne,t)},update:async()=>{let t=se();await ie(ne,t)}};m();import{readFile as X3,writeFile as re}from"fs/promises";var Q3=["./.stylelintrc.mjs","./stylelint.config.mjs","./.stylelintrc.cjs","./stylelint.config.cjs","./.stylelintrc.js","./stylelint.config.js","./.stylelintrc","./.stylelintrc.json","./.stylelintrc.yml","./.stylelintrc.yaml"],ae="./stylelint.config.mjs",K3=async()=>{try{return"stylelint"in JSON.parse(await X3("./package.json","utf-8"))}catch{return!1}},Y3=async()=>{if(await K3())return"./package.json";for(let t of Q3)if(await l(t))return t;return null},ce=()=>`export { default } from "ultracite/stylelint";
`,z1={exists:async()=>await Y3()!==null,create:async()=>{let t=ce();await re(ae,t)},update:async()=>{let t=ce();await re(ae,t)}};import{readFile as Z3,writeFile as le}from"fs/promises";import{glob as q3}from"glob";import{applyEdits as to,modify as eo,parse as oo}from"jsonc-parser";var fe=async()=>{try{return await q3("**/tsconfig*.json",{ignore:["**/node_modules/**","**/dist/**","**/build/**","**/.next/**"],absolute:!1})}catch{return[]}},io=t=>{if(!t)return!1;let e=t.compilerOptions;return e?e.strict===!0||e.strictNullChecks===!0:!1},no=async t=>{try{let e=await Z3(t,"utf-8"),o=oo(e);if(io(o))return;if(o===void 0){await le(t,JSON.stringify({compilerOptions:{strictNullChecks:!0}},null,2));return}let n=eo(e,["compilerOptions","strictNullChecks"],!0,{formattingOptions:{tabSize:2,insertSpaces:!0}}),s=to(e,n);await le(t,s)}catch(e){console.warn(`Failed to update ${t}:`,e)}},M1={exists:async()=>(await fe()).length>0,update:async()=>{let t=await fe();if(t.length===0){console.warn("No tsconfig.json files found in the project");return}await Promise.all(t.map(e=>no(e)))}};m();var de=k.devDependencies["@biomejs/biome"],J1=k.version,fo=async(t,e="biome",o=!0,i=!1,n=!1)=>{let s=g();i||s.start("Installing dependencies...");let r=[`ultracite@${J1}`];if(e==="biome"&&r.push(`@biomejs/biome@${de}`),e==="eslint"&&(r.push("eslint@latest"),r.push("prettier@latest"),r.push("stylelint@latest")),e==="oxlint"&&(r.push("oxlint@latest"),r.push("oxfmt@latest"),n&&r.push("oxlint-tsgolint@latest")),o)for(let a of r)await co(a,{packageManager:t,workspace:await j(),silent:!0});else{let a={ultracite:J1};e==="biome"&&(a["@biomejs/biome"]=de),e==="eslint"&&(a.eslint="latest",a.prettier="latest",a.stylelint="latest"),e==="oxlint"&&(a.oxlint="latest",a.oxfmt="latest",n&&(a["oxlint-tsgolint"]="latest")),await b({devDependencies:a})}i||s.stop("Dependencies installed.")},mo=async(t=!1)=>{let e=g();if(t||e.start("Checking for tsconfig.json files..."),await M1.exists()){t||e.message("Found tsconfig.json files, updating with strictNullChecks..."),await M1.update(),t||e.stop("tsconfig.json files updated.");return}t||e.stop("No tsconfig.json files found, skipping.")},po=async(t,e="biome",o=!1)=>{let i=S.find(r=>r.id===t);if(!i)throw new Error(`Editor "${t}" not found`);let n=_t(t,e),s=g();if(o||s.start(`Checking for ${i.config.path}...`),await n.exists()){o||s.message(`${i.config.path} found, updating...`),await n.update(),o||s.stop(`${i.config.path} updated.`);return}if(o||s.message(`${i.config.path} not found, creating...`),await n.create(),n.extension){let r=D.find(a=>a.id===e)?.vscodeExtensionId;if(!r)throw new Error(`Linter extension not found for ${e}`);o||s.message(`Installing ${r} extension...`);try{if(n.extension(r).status===0){o||s.stop(`${i.config.path} created and ${r} extension installed.`);return}}catch{}o||s.stop(`${i.config.path} created. Install ${r} extension manually.`);return}o||(t==="zed"?s.stop(`${i.config.path} created. Install the Biome extension: https://biomejs.dev/reference/zed/`):s.stop(`${i.config.path} created.`))},go=async(t,e=!1)=>{let o=g();if(e||o.start("Checking for Biome configuration..."),await u1.exists()){e||o.message("Biome configuration found, updating..."),await u1.update({frameworks:t}),e||o.stop("Biome configuration updated.");return}e||o.message("Biome configuration not found, creating..."),await u1.create({frameworks:t}),e||o.stop("Biome configuration created.")},ho=async(t,e=!1)=>{let o=g();if(e||o.start("Checking for ESLint configuration..."),await w1.exists()){e||o.message("ESLint configuration found, updating..."),await w1.update({frameworks:t}),e||o.stop("ESLint configuration updated.");return}e||o.message("ESLint configuration not found, creating..."),await w1.create({frameworks:t}),e||o.stop("ESLint configuration created.")},uo=async(t,e=!1)=>{let o=g();if(e||o.start("Checking for Oxlint configuration..."),await k1.exists()){e||o.message("Oxlint configuration found, updating..."),await k1.update({frameworks:t}),e||o.stop("Oxlint configuration updated.");return}e||o.message("Oxlint configuration not found, creating..."),await k1.create({frameworks:t}),e||o.stop("Oxlint configuration created.")},wo=async(t=!1)=>{let e=g();if(t||e.start("Checking for Prettier configuration..."),await b1.exists()){t||e.message("Prettier configuration found, updating..."),await b1.update(),t||e.stop("Prettier configuration updated.");return}t||e.message("Prettier configuration not found, creating..."),await b1.create(),t||e.stop("Prettier configuration created.")},xo=async(t=!1)=>{let e=g();if(t||e.start("Checking for Stylelint configuration..."),await z1.exists()){t||e.message("Stylelint configuration found, updating..."),await z1.update(),t||e.stop("Stylelint configuration updated.");return}t||e.message("Stylelint configuration not found, creating..."),await z1.create(),t||e.stop("Stylelint configuration created.")},vo=async(t=!1)=>{let e=g();if(t||e.start("Checking for oxfmt configuration..."),await v1.exists()){t||e.message("oxfmt configuration found, updating..."),await v1.update(),t||e.stop("oxfmt configuration updated.");return}t||e.message("oxfmt configuration not found, creating..."),await v1.create(),t||e.stop("oxfmt configuration created.")},yo=async(t,e=!0,o=!1)=>{let i=g();if(o||(i.start("Initializing pre-commit hooks..."),i.message("Installing Husky...")),e?await F.install(t):await b({devDependencies:{husky:"latest"},scripts:{prepare:"husky"}}),o||i.message("Initializing Husky..."),F.init(t),await F.exists()){o||i.message("Pre-commit hook found, updating..."),await F.update(t),o||i.stop("Pre-commit hook updated.");return}o||i.message("Pre-commit hook not found, creating..."),await F.create(t),o||i.stop("Pre-commit hook created.")},ko=async(t,e=!0,o=!1)=>{let i=g();if(o||(i.start("Initializing lefthook..."),i.message("Installing lefthook...")),e?await V.install(t):await b({devDependencies:{lefthook:"latest"}}),await V.exists()){o||i.message("lefthook.yml found, updating..."),await V.update(t),o||i.stop("lefthook.yml updated.");return}o||i.message("lefthook.yml not found, creating..."),await V.create(t),o||i.stop("lefthook.yml created.")},bo=async(t,e=!0,o=!1)=>{let i=g();if(o||(i.start("Initializing lint-staged..."),i.message("Installing lint-staged...")),e?await X.install(t):await b({devDependencies:{"lint-staged":"latest"}}),await X.exists()){o||i.message("lint-staged found, updating..."),await X.update(t),o||i.stop("lint-staged updated.");return}o||i.message("lint-staged not found, creating..."),await X.create(t),o||i.stop("lint-staged created.")},zo=async(t,e=!1)=>{let o=g();if(e||o.start("Initializing pre-commit..."),await t1.exists()){e||o.message(".pre-commit-config.yaml found, updating..."),await t1.update(t),e||o.stop(".pre-commit-config.yaml updated.");return}e||o.message(".pre-commit-config.yaml not found, creating..."),await t1.create(t),e||o.stop(".pre-commit-config.yaml created.")},Co=async(t,e,o,i,n=!1)=>{let s=g();n||s.start(`Checking for ${e}...`);let r=$t(t,o,i);if(await r.exists()){n||s.message(`${e} found, updating...`),await r.update(),n||s.stop(`${e} updated.`);return}n||s.message(`${e} not found, creating...`),await r.create(),n||s.stop(`${e} created.`)},So=async(t,e,o=!1)=>{let i=g(),n=I.find(r=>r.id===t)?.name??t;o||i.start(`Checking for ${n} hooks...`);let s=Lt(t,e);if(await s.exists()){o||i.message(`${n} hooks found, updating...`),await s.update(),o||i.stop(`${n} hooks updated.`);return}o||i.message(`${n} hooks not found, creating...`),await s.create(),o||i.stop(`${n} hooks created.`)},me=async t=>{let e=t??{},o=e.quiet??!1;o||ro(`Ultracite v${J1} Initialization`);try{let{pm:i}=e;if(!i){let d=await lo(so.cwd());if(!d)throw new Error("No package manager specified or detected");if(!o&&d.warnings)for(let h of d.warnings)C1.warn(h);o||C1.info(`Detected lockfile, using ${d.name}`),i=d.name}let n=e.linter;if(n===void 0)if(o||e.pm||e.editors||e.agents||e.hooks||e.integrations!==void 0||e.frameworks!==void 0)n="biome";else{let h=await ao({message:"Which linter do you want to use?",options:[{label:"Biome (Recommended)",value:"biome"},{label:"ESLint + Prettier + Stylelint",value:"eslint"},{label:"Oxlint + Oxfmt",value:"oxlint"}]});if(Y(h)){K("Operation cancelled.");return}n=h}let s=e.frameworks;if(s===void 0)if(o||e.pm||e.editors||e.agents||e.hooks||e.integrations!==void 0)s=[];else{let h=await o1({message:"Which frameworks are you using (optional)?",options:[{label:"React",value:"react"},{label:"Next.js",value:"next"},{label:"Solid",value:"solid"},{label:"Vue",value:"vue"},{label:"Svelte",value:"svelte"},{label:"Qwik",value:"qwik"},{label:"Angular",value:"angular"},{label:"Remix / TanStack Router / React Router",value:"remix"},{label:"Astro",value:"astro"}],required:!1});if(Y(h)){K("Operation cancelled.");return}s=h}let r=e.editors;if(!r)if(o)r=[];else{let d=await o1({message:"Which editors do you want to configure (recommended)?",options:[{label:"VSCode / Cursor / Windsurf",value:"vscode"},{label:"Zed",value:"zed"}],required:!1});if(Y(d)){K("Operation cancelled.");return}r=d}let a=e.agents,f=e.hooks,p=Object.fromEntries(C.map(d=>[d.id,d.name]));if(!a)if(o)a=[];else{let d=await o1({message:"Which agents do you want to enable (optional)?",options:Object.entries(p).map(([h,S1])=>({value:h,label:S1})),required:!1});if(Y(d)){K("Operation cancelled.");return}a=d}let y=Object.fromEntries(I.map(d=>[d.id,d.name]));if(!f)if(o)f=[];else{let d=await o1({message:"Which agent hooks do you want to enable (optional)?",options:Object.entries(y).map(([h,S1])=>({value:h,label:S1})),required:!1});if(Y(d)){K("Operation cancelled.");return}f=d}let x=e.integrations;if(x===void 0)if(o||e.pm||e.editors||e.agents||e.hooks)x=[];else{let h=await o1({message:"Would you like any of the following (optional)?",options:[{label:"Husky pre-commit hook",value:"husky"},{label:"Lefthook pre-commit hook",value:"lefthook"},{label:"Lint-staged",value:"lint-staged"},{label:"pre-commit (Python framework)",value:"pre-commit"}],required:!1});if(Y(h)){K("Operation cancelled.");return}x=h}await fo(i,n,!e.skipInstall,o,n==="oxlint"&&e["type-aware"]),await mo(o),n==="biome"&&await go(s,o),n==="eslint"&&(await ho(s,o),await wo(o),await xo(o)),n==="oxlint"&&(await uo(s,o),await vo(o));for(let d of r??[])await po(d,n,o);for(let d of a??[])await Co(d,p[d],i,n,o);for(let d of f??[])await So(d,i,o);x?.includes("husky")&&await yo(i,!e.skipInstall,o),x?.includes("lefthook")&&await ko(i,!e.skipInstall,o),x?.includes("lint-staged")&&await bo(i,!e.skipInstall,o),x?.includes("pre-commit")&&await zo(i,o),o||C1.success("Successfully initialized Ultracite! Make sure to check out ultracite.ai/cloud for our pro version.")}catch(i){let n=i instanceof Error?i.message:"Unknown error";throw o||C1.error(`Failed to initialize Ultracite configuration: ${n}`),i}};var i1=jo.meta().create(),Ao=i1.router({init:i1.procedure.meta({description:"Initialize Ultracite in the current directory"}).input(c.object({pm:c.enum(Po.map(t=>t.name)).optional().describe("Package manager to use"),linter:c.enum(v.linters).optional().describe("Linter / formatter to use"),editors:c.array(c.enum(v.editorConfigs)).optional().describe("Editors to configure"),agents:c.array(c.enum(v.agents)).optional().describe("Agents to enable"),hooks:c.array(c.enum(v.hooks)).optional().describe("Hooks to enable"),frameworks:c.array(c.enum(v.frameworks)).optional().describe("Frameworks being used"),integrations:c.array(c.enum(v.integrations)).optional().describe("Additional integrations to enable"),migrate:c.array(c.enum(v.migrations)).optional().describe("Migration tools to remove (e.g., eslint, prettier). Removes dependencies, config files, and editor settings."),"type-aware":c.boolean().optional().describe("enable type-aware linting (oxlint only, installs oxlint-tsgolint)"),skipInstall:c.boolean().default(!1).describe("Skip installing dependencies"),quiet:c.boolean().default(process.env.CI==="true"||process.env.CI==="1").describe("Suppress all interactive prompts and visual output. Automatically enabled in CI environments.")})).mutation(async({input:t})=>{await me(t)}),check:i1.procedure.meta({description:"Run linter without fixing files"}).input(c.tuple([c.array(c.string()).optional().default([]).describe("specific files to lint"),c.object({"diagnostic-level":c.enum(["info","warn","error"]).optional().describe("level of diagnostics to show. In order, from the lowest to the most important: info, warn, error."),linter:c.enum(v.linters).optional().describe("linter to use (biome, eslint, or oxlint)"),"type-aware":c.boolean().optional().describe("enable type-aware linting rules (oxlint only)"),"type-check":c.boolean().optional().describe("enable TypeScript compiler diagnostics (oxlint only)"),"no-error-on-unmatched-pattern":c.boolean().optional().describe("suppress errors when files don't match patterns (useful for hooks/CI)"),"error-on-warnings":c.boolean().optional().describe("treat warnings as errors (biome only)")})]).optional()).query(async({input:t})=>{if((await At(t)).hasErrors)throw new Error("Lint errors found")}),fix:i1.procedure.meta({description:"Run linter and fix files"}).input(c.tuple([c.array(c.string()).optional().default([]).describe("specific files to format"),c.object({unsafe:c.boolean().optional().describe("apply unsafe fixes"),linter:c.enum(v.linters).optional().describe("linter to use (biome, eslint, or oxlint)"),"type-aware":c.boolean().optional().describe("enable type-aware linting rules (oxlint only)"),"type-check":c.boolean().optional().describe("enable TypeScript compiler diagnostics (oxlint only)"),"error-on-warnings":c.boolean().optional().describe("treat warnings as errors (biome only)")})]).optional()).mutation(async({input:t})=>{let[e,o]=t??[[],{}];if((await Bt(e,{unsafe:o.unsafe,linter:o.linter,"type-aware":o["type-aware"],"type-check":o["type-check"],"error-on-warnings":o["error-on-warnings"]})).hasErrors)throw new Error("Lint errors found")}),doctor:i1.procedure.meta({description:"Verify your Ultracite setup and check for issues"}).query(async()=>{await Ot()})}),Io=Eo({router:Ao,name:k.name,version:k.version,description:k.description});process.env.TEST||Io.run();export{Ao as router};
